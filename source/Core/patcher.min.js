"use strict";globalThis.CyclonePatcher=class{static initialize(t){this.pluginName=t,this.superClasses=new Map}static _descriptorIsProperty(t){return t.get||t.set||!t.value||"function"!=typeof t.value}static _getAllClassDescriptors(t,e=!1){if(t===Object)return{};const s=Object.getOwnPropertyDescriptors(e?t.prototype:t);let r={};if(t.prototype){const s=Object.getPrototypeOf(t.prototype).constructor;s!==Object&&(r=this._getAllClassDescriptors(s,e))}return Object.assign({},r,s)}static _assignDescriptor(t,e,s,r,i=!1){if(this._descriptorIsProperty(s))s.get||s.set?Object.defineProperty(t,r,{get:s.get,set:s.set,enumerable:s.enumerable,configurable:s.configurable}):Object.defineProperty(t,r,{value:s.value,enumerable:s.enumerable,configurable:s.configurable});else{let s=r;if(i)for(;s in t;)s=`_${s}`;t[s]=e[r]}}static _applyPatch(t,e,s,r,i=!1){const o=this._getAllClassDescriptors(t,i),c=i?t.prototype:t,a=i?e.prototype:e,n=Object.getOwnPropertyDescriptors(a);let p=!1;for(const t in n){if(r.includes(t))continue;if(t in o){p=!0;const e=o[t];this._assignDescriptor(s,c,e,t,!0)}const e=n[t];this._assignDescriptor(c,a,e,t)}return p}static patchClass(t,e){const s=this.superClasses&&this.superClasses[t.name]||{},r={},i={},o=e(i,r);if("function"!=typeof o)throw new Error(`Invalid class patch for ${t.name}`);const c=Object.getOwnPropertyNames(class{}),a=Object.getOwnPropertyNames(class{}.prototype),n=this._applyPatch(t,o,s,c),p=this._applyPatch(t,o,r,a,!0);if(n){const t=Object.getOwnPropertyDescriptors(s);for(const e in t)this._assignDescriptor(i,s,t[e],e);p&&(i.$prototype=r)}else Object.assign(i,r);this.superClasses&&(this.superClasses[t.name]=i)}};
